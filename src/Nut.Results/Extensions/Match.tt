<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ include file="../../GenerationLibs/MatchGenLibs.ttinclude"#>
<#
    var targetTypes = new TargetType[]
    {
        new (false, TaskType.None),
        new (true, TaskType.None),
        new (false, TaskType.Task),
        new (true, TaskType.Task),
        new (false, TaskType.ValueTask),
        new (true, TaskType.ValueTask),
    };

    string GetMethodName(TargetType returnType, TargetType sourceType)
    {
        if (sourceType.IsGeneric && returnType.IsGeneric)
        {
            return "Match<T, TResult>";
        }
        if (sourceType.IsGeneric && !returnType.IsGeneric)
        {
            return "Match<T>";
        }
        if (!sourceType.IsGeneric && returnType.IsGeneric)
        {
            return "Match<TResult>";
        }
        return "Match";
    }

    string GetOkType(TargetType sourceType, TargetType okType)
    {
        if (sourceType.IsGeneric)
        {
            if (okType.IsTask)
            {
                return okType.IsGeneric ? $"Func<T, {okType.TaskType}<Result<TResult>>>" : $"Func<T, {okType.TaskType}<Result>>";
            }
            return okType.IsGeneric ? $"Func<T, Result<TResult>>" : $"Func<T, Result>";
        }
        if (okType.IsTask)
        {
            return okType.IsGeneric ? $"Func<{okType.TaskType}<Result<TResult>>>" : $"Func<{okType.TaskType}<Result>>";
        }
        return okType.IsGeneric ? $"Func<Result<TResult>>" : $"Func<Result>";
    }
    string GetErrorType(TargetType errType)
    {
        if (errType.IsTask)
        {
            return errType.IsGeneric ? $"Func<IError, {errType.TaskType}<Result<TResult>>>" : $"Func<IError, {errType.TaskType}<Result>>";
        }
        return errType.IsGeneric ? $"Func<IError, Result<TResult>>" : $"Func<IError, Result>";
    }

    bool NeedDummyParamCode(MethodProcessor p)
        => (p.Error.TaskType == TaskType.ValueTask && p.Ok.TaskType != TaskType.ValueTask) ||
           (p.Error.TaskType == TaskType.None && p.Ok.TaskType == TaskType.ValueTask);

    string GetDummyParamCodeIfNeeded(MethodProcessor p)
    {
        if (NeedDummyParamCode(p))
        {
            return ", DummyParam? _ = null";
        }
        return string.Empty;
    }

    string GetSourceParamDec(MethodProcessor p)
        => (p.CanInParam() ? "in " : "") + p.Source.GetTypeText();

#>// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Nut.Results;

public static partial class ResultExtensions
{
<#
    foreach (var rt in targetTypes)
    {
        foreach (var st in targetTypes)
        {
            // if(st.TaskType == TaskType.ValueTask) continue;

            foreach (var ot in targetTypes)
            {
                foreach (var et in targetTypes)
                {
                    var p = new MethodProcessor(rt, st, ot, et);
                    if(!p.CanDeclareMethod()) continue;
#>
    /// <summary>
    /// 結果が成功の場合は、<paramref name="ok"/> の結果を返し、失敗の場合は <paramref name="err"/> の結果を返します。
<#
                    if (rt.IsTask)
                    {
#>
    /// Lambdaを使った場合にオーバーロードが解決できないときは <see cref="Nut.Results.AsyncLambdaSupport" /> の利用を検討してください。
<#
                    }
#>

    /// </summary>
    /// <param name="source">もととなる <see cref="Result"/></param>
    /// <param name="ok">成功の場合に実行される処理</param>
    /// <param name="err">失敗の場合に実行される処理</param>
<#
                    if (NeedDummyParamCode(p))
                    {
#>
    /// <param name="_">オーバーロードを解決するためのダミーパラメーターです。利用しません。</param>
<#

                    }
#>
<#
                    if (st.IsGeneric)
                    {
#>
    /// <typeparam name="T">成功の値の型</typeparam>
<#
                    }
#>
<#
                    if (rt.IsGeneric)
                    {
#>
    /// <typeparam name="TResult">返される結果の成功の値の型</typeparam>
<#
                    }
#>
    /// <returns>処理の結果</returns>
    public static<#= p.IsAsyncMethod() ? " async" : "" #> <#= rt.GetTypeText(true) #> <#= GetMethodName(rt, st) #>(this <#= GetSourceParamDec(p) #> source, <#=GetOkType(st, ot)#> ok, <#=GetErrorType(et)#> err<#=GetDummyParamCodeIfNeeded(p)#>)
    {
<#
                    if (st.TaskType == TaskType.Task)
                    {
#>
        if (source is null) throw new ArgumentNullException(nameof(source));
<#
                    }
#>
        if (ok is null) throw new ArgumentNullException(nameof(ok));
        if (err is null) throw new ArgumentNullException(nameof(err));

        var sourceValue = <#= st.IsTask ? "await source.ConfigureAwait(false)" : "source" #>;
        if (sourceValue.IsOk) {
            return <#= p.NeedAwaitOk() ? "await " : "" #>ok(<#= st.IsGeneric ? "sourceValue._value" : "" #>)<#= p.NeedAwaitOk() ? ".ConfigureAwait(false)" : "" #>;
        }
        return <#= p.NeedAwaitError() ? "await " : "" #>err(sourceValue._errorValue)<#= p.NeedAwaitError() ? ".ConfigureAwait(false)" : "" #>;
    }
<#
                }
            }
        }
    }
#>
}
