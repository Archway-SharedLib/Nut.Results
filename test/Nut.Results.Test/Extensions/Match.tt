<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ include file="../../../src/GenerationLibs/MatchGenLibs.ttinclude"#>
<#
    var targetTypes = new TargetType[]
    {
        new (false, TaskType.None),
        new (true, TaskType.None),
        new (false, TaskType.Task),
        new (true, TaskType.Task),
        // new (false, TaskType.ValueTask),
        // new (true, TaskType.ValueTask),
    };

    string GetTestMethodTypeText(TargetType t)
        => (t.TaskType != TaskType.None ? t.TaskType.ToString() : "") + "Res" + (t.IsGeneric ? "T" : "");

    string GetTestMethodPrefix(MethodProcessor p)
        =>
            $"{GetTestMethodTypeText(p.Return)}_{GetTestMethodTypeText(p.Source)}_{GetTestMethodTypeText(p.Ok)}_{GetTestMethodTypeText(p.Error)}";

    string T(bool condition, string text) => condition ? text : string.Empty;
#>// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using FluentAssertions;
using Nut.Results.FluentAssertions;
using Xunit;

namespace Nut.Results.Test;

public partial class Match
{
<#
    foreach (var rt in targetTypes)
    {
        foreach (var st in targetTypes)
        {
            // if(st.TaskType == TaskType.ValueTask) continue;

            foreach (var ot in targetTypes)
            {
                foreach (var et in targetTypes)
                {
                    var p = new MethodProcessor(rt, st, ot, et);
                    if (!p.CanDeclareMethod()) continue;
#>
    [Fact]
    public <#= rt.IsTask ? "async Task" : "void" #> <#= GetTestMethodPrefix(p) #>_Okがnullの場合は例外が発生する()
    {
        var act = () => ResultExtensions.Match(Result.Ok(<#=T(st.IsGeneric, "1")#>)<#=T(st.IsTask, $".As{st.TaskType}()")#>, (Func<<#=T(st.IsGeneric, "int, ")#><#=T(ot.TaskType != TaskType.None, $"{ot.TaskType}<")#>Result<#=T(ot.IsGeneric, "<int>")#>><#=T(ot.TaskType != TaskType.None, ">")#>)null, (_) => Result.Ok(<#=T(et.IsGeneric, "1")#>)<#=T(et.IsTask, $".As{et.TaskType}()")#>)<#=T(rt.TaskType == TaskType.ValueTask, ".AsTask()")#>;
        <#= T(rt.IsTask,"await ")#>act.Should().Throw<#= T(rt.IsTask, "Async")#><ArgumentNullException>();
    }

    [Fact]
    public <#= rt.IsTask ? "async Task" : "void" #> <#= GetTestMethodPrefix(p) #>_Errorがnullの場合は例外が発生する()
    {
        var act = () => ResultExtensions.Match(Result.Ok(<#=T(st.IsGeneric, "1")#>)<#=T(st.IsTask, $".As{st.TaskType}()")#>, (<#=T(st.IsGeneric, "_")#>) => Result.Ok(<#=T(ot.IsGeneric, "1")#>)<#=T(ot.TaskType != TaskType.None, $".As{ot.TaskType}()")#>, (Func<IError, <#=T(et.TaskType != TaskType.None, $"{et.TaskType}<")#>Result<#=T(et.IsGeneric, "<int>")#>><#=T(et.TaskType != TaskType.None, ">")#>)null)<#=T(rt.TaskType == TaskType.ValueTask, ".AsTask()")#>;
        <#= rt.IsTask ? "await " : ""#>act.Should().Throw<#= rt.IsTask ? "Async" : ""#><ArgumentNullException>();
    }

<#
                    if (st.TaskType == TaskType.Task)
                    {
#>
    [Fact]
    public async Task <#= GetTestMethodPrefix(p) #>_Sourceがnullの場合は例外が発生する()
    {
        var act = () => ResultExtensions.Match((Task<Result<#=T(st.IsGeneric, "<int>")#>>)null, (<#=T(st.IsGeneric, "_")#>) => Result.Ok(<#=T(ot.IsGeneric, "1")#>)<#=T(ot.TaskType != TaskType.None, $".As{ot.TaskType}()")#>, (_) => Result.Ok(<#=T(et.IsGeneric, "1")#>)<#=T(et.TaskType != TaskType.None, $".As{et.TaskType}()")#>)<#=T(rt.TaskType == TaskType.ValueTask, ".AsTask()")#>;
        await act.Should().ThrowAsync<ArgumentNullException>();
    }

<#
                    }
#>
    [Fact]
    public <#= rt.IsTask ? "async Task" : "void" #> <#= GetTestMethodPrefix(p) #>_Okの場合はokが実行される()
    {
        var executedOk = false;
        var executedError = false;
        var result = <#=T(rt.IsTask,"await ")#>Result.Ok(<#=T(st.IsGeneric,"1")#>)<#=T(st.TaskType != TaskType.None,$".As{st.TaskType}()")#>.Match((<#=T(st.IsGeneric, "v")#>) =>
        {
            <#=T(st.IsGeneric, "v.Should().Be(1);")#>
            executedOk = true;
            return Result.Ok(<#=T(ot.IsGeneric,"1")#>)<#=T(ot.TaskType != TaskType.None,$".As{ot.TaskType}()")#>;
        }, err =>
        {
            executedError = true;
            return Result.Error<#=T(et.IsGeneric,"<int>")#>(err)<#=T(et.TaskType != TaskType.None,$".As{et.TaskType}()")#>;
        });
        result.Should().BeOk();
        executedOk.Should().BeTrue();
        executedError.Should().BeFalse();
    }

    [Fact]
    public <#= rt.IsTask ? "async Task" : "void" #> <#= GetTestMethodPrefix(p) #>_Errorの場合はerrが実行される()
    {
        var executedOk = false;
        var executedError = false;
        var err = new Error();
        var result = <#=T(rt.IsTask,"await ")#>Result.Error<#=T(st.IsGeneric,"<int>")#>(err)<#=T(st.TaskType != TaskType.None,$".As{st.TaskType}()")#>.Match((<#=T(st.IsGeneric, "v")#>) =>
        {
            <#=T(st.IsGeneric, "v.Should().Be(1);")#>
            executedOk = true;
            return Result.Ok(<#=T(ot.IsGeneric,"1")#>)<#=T(ot.TaskType != TaskType.None,$".As{ot.TaskType}()")#>;
        }, err =>
        {
            executedError = true;
            return Result.Error<#=T(et.IsGeneric,"<int>")#>(err)<#=T(et.TaskType != TaskType.None,$".As{et.TaskType}()")#>;
        });
        result.Should().BeError().And.Match(error => err == error);
        executedOk.Should().BeFalse();
        executedError.Should().BeTrue();
    }

<#
                }
            }
        }
    }
#>
}
